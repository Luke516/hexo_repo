Off Axis Projection

一般來說，我們在openGL中計算投影矩陣的時候，會使用glPerspective和GluLookat一類的函數(或者是用GLM中類似的類別)。但是這樣的投影方式其實有個限制：不論用的是lookAt或Perspective矩陣，預設的調間都是使用者必須正對著螢幕，並且假設使用者的眼睛是在螢幕正中央的位置。

複習一下吧：

當然，這樣的前提在一般的情況下是沒什麼問題的，畢竟正常人用電腦應該都是正對著螢幕沒錯，不過在某些特殊情況下就不是這樣了。我們可以先看一下這個影片：

會想探討這個問題，也是因為修了"訊號與系統"這堂課，而我們的目標就是實作類似上面影片的效果。

那麼，我們該怎麼做呢？首先，很明顯的，我們不能用lookAt或Perspective矩陣，因為不符合我們剛剛所說的前提。
1.lookAt：lookAt矩陣其實就是由一個旋轉矩陣再加上一個位移矩陣所組成，由於現在使用者的視線不一定要正對著 
2.perspective：這個矩陣就是比較麻煩的地方了

我一開始想到的做法其實很簡單也滿直觀的，就是用glFrustum來取代glPerspective。因為事實上它就是glPerspective更泛用的版本，可以用上、下、左、右、前、後六個參數表示所有視錐的情況，而沒有perspective的限制。

假設螢幕就是我們的投影平面，那麼當使用者的頭左右移動時，視錐應該會有如下的變化：

套用到frustum的參數裡，就會表現如下的結果：

不過，這樣出來的結果雖然是對的，卻有一個問題：由於zNear平面實際上就是螢幕，而距離zNear之內的物體都會被clipping給去掉，所以出來的結果會沒辦法呈現出物體凸出螢幕的感覺，會感覺不那麼立體。(什麼是凸出螢幕的感覺？再把上面影片的部分看一次吧)

這個問題要如何改善呢？首先很明顯的，想要達到凸出螢幕的效果，zNear平面就不可以剛好在螢幕的位置上。因此，我們需要一個虛擬的投影平面，這個平面距離攝影機的值是zNear，這時zNear的值就可以小於攝影機到螢幕的距離。不過在這樣的情況下，這個投影平面的上下左右邊界又該怎麼計算呢？


從上圖可以看到，利用相似三角形的概念，新的左右邊界(R'跟L')就是把原本攝影機距離螢幕左右邊界的值，除以攝影機跟螢幕的垂直距離，再乘以zNear的值。而上下邊界的值也是這樣處理。

大概清楚概念之後，以下是範例code : 

```
	glm::mat4 Projection = glm::mat4(glm::frustum( 
		(-0.17f- head_position.x)*zNear/head_position.z,
		(0.17f- head_position.x)*zNear/head_position.z,
		(-0.10f - head_position.y)*zNear/head_position.z,
		(0.10f - head_position.y)*zNear/head_position.z,
		zNear, 
		zFar+head_position.z ));
```

在這裡的-0.17和0.17就是螢幕的左右界，-0.1跟0.1就是螢幕的上下界。會設定成這樣的數值是因為我的電腦螢幕大約是34*20公分。而這裡的單位因為我們是用公尺來算，所以除以100之後就是0.34跟0.2，而原點設在螢幕中心，這樣就能算出座標的值了，圖示如下：


最後附上我們課程專題最後拍的影片~



備註：這篇文章只有說明如何用openGL做off-axis projection以達到這樣的畫面效果。至於如何讓程式知道攝影機的位置，基本上不在這篇文章的範圍之內。不過可以稍微提一下，我們是用六軸的加速規+陀螺儀來計算位置，而實際上這樣的作法誤差會很大(因為要做兩次積分)，我們的影片之所以看起來效果還可以，是因為